{"version":3,"file":"provider.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/di/provider.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\n\n/**\n * Configures the {@link Injector} to return an instance of `Type` when `Type' is used as token.\n *\n * Create an instance by invoking the `new` operator and supplying additional arguments.\n * This form is a short form of `TypeProvider`;\n *\n * ### Example\n * ```javascript\n * @Injectable()\n * class Greeting {\n *   text: 'Hello';\n * }\n *\n * @Injectable()\n * class MyClass {\n *   greeting:string;\n *   constructor(greeting: Greeting) {\n *     this.greeting = greeting.text;\n *   }\n * }\n *\n * const injector = Injector.resolveAndCreate([\n *   Greeting, // Shorthand for { provide: Greeting, useClass: Greeting }\n *   MyClass   // Shorthand for { provide: MyClass,  useClass: MyClass }\n * ]);\n *\n * const myClass: MyClass = injector.get(MyClass);\n * expect(myClass.greeting).toEqual('Hello');\n * ```\n *\n * @stable\n */\nexport interface TypeProvider extends Type<any> {}\n\n/**\n * Configures the {@link Injector} to return a value for a token.\n *\n * ### Example\n * const injector = Injector.resolveAndCreate([\n *   {provide: String, useValue: 'Hello'}\n * ]);\n *\n * expect(injector.get(String)).toEqual('Hello');\n * ```\n * @stable\n */\nexport interface ValueProvider {\n  /**\n   * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).\n   */\n  provide: any;\n\n  /**\n   * The value to inject.\n   */\n  useValue: any;\n\n  /**\n   * If true, than injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   *\n   * ### Example\n   * ```javascript\n   * var locale = new OpaqueToken('local');\n   *\n   * const injector = Injector.resolveAndCreate([\n   *   { provide: locale, useValue: 'en' },\n   *   { provide: locale, useValue: 'sk' },\n   * ]);\n   *\n   * const locales: string[] = injector.get(locale);\n   * expect(locales).toEqual(['en', 'sk']);\n   * ```\n   */\n  multi?: boolean;\n}\n\n/**\n * Configures the {@link Injector} to return an instance of `useClass` for a token.\n *\n * ### Example\n * ```javascript\n * abstract class Shape {\n *   name: string;\n * }\n *\n * class Square extends Shape {\n *   name = 'square';\n * }\n *\n * const injector = Injector.resolveAndCreate([\n *   {provide: Shape, useClass: Square}\n * ]);\n *\n * const shape: Shape = injector.get(Shape);\n * expect(shape.name).toEqual('square');\n * expect(shape instanceof Square).toBe(true);\n * ```\n *\n * Note that following is not equal:\n * ```javascript\n * class Greeting {\n *   salutation = 'Hello';\n * }\n *\n * class FormalGreeting extends Greeting {\n *   salutation = 'Greetings';\n * }\n *\n * const injector = Injector.resolveAndCreate([\n *   FormalGreeting,\n *   {provide: Greeting, useClass: FormalGreeting}\n * ]);\n *\n * // The injector returns different instances.\n * // See: {provide: ?, useExisting: ?} if you want the same instance.\n * expect(injector.get(FormalGreeting)).not.toBe(injector.get(Greeting));\n * ```\n *\n * @stable\n */\nexport interface ClassProvider {\n  /**\n   * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).\n   */\n  provide: any;\n\n  /**\n   * Class to instantiate for the `token`.\n   */\n  useClass: Type<any>;\n\n  /**\n   * If true, than injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   *\n   * ### Example\n   * ```javascript\n   * abstract class Locale {\n   *   name: string;\n   * };\n   *\n   * @Injectable()\n   * class EnLocale extends Locale {\n   *   name: 'en';\n   * };\n   *\n   * @Injectable()\n   * class SkLocale extends Locale {\n   *   name: 'sk';\n   * };\n   *\n   * const injector = Injector.resolveAndCreate([\n   *   { provide: Locale, useValue: EnLocale, multi: true },\n   *   { provide: Locale, useValue: SkLocale, multi: true },\n   * ]);\n   *\n   * const locales: Locale[] = injector.get(Locale);\n   * const localeNames: string[] = locals.map((l) => l.name);\n   * expect(localeNames).toEqual(['en', 'sk']);\n   * ```\n   */\n  multi?: boolean;\n}\n\n/**\n * Configures the {@link Injector} to return a value of another `useExisting` token.\n *\n * ### Example\n * ```javascript\n * class Greeting {\n *   salutation = 'Hello';\n * }\n *\n * class FormalGreeting extends Greeting {\n *   salutation = 'Greetings';\n * }\n *\n * const injector = Injector.resolveAndCreate([\n *   FormalGreeting,\n *   {provide: Greeting, useExisting: FormalGreeting}\n * ]);\n *\n * expect(injector.get(Greeting).name).toEqual('Hello');\n * expect(injector.get(FormalGreeting).name).toEqual('Hello');\n * expect(injector.get(Salutation).name).toBe(injector.get(Greeting));\n * ```\n * @stable\n */\nexport interface ExistingProvider {\n  /**\n   * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).\n   */\n  provide: any;\n\n  /**\n   * Existing `token` to return. (equivalent to `injector.get(useExisting)`)\n   */\n  useExisting: any;\n\n  /**\n   * If true, than injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   *\n   * ### Example\n   * ```javascript\n   * abstract class Locale {\n   *   name: string;\n   * };\n   *\n   * @Injectable()\n   * class EnLocale extends Locale {\n   *   name: 'en';\n   * };\n   *\n   * @Injectable()\n   * class SkLocale extends Locale {\n   *   name: 'sk';\n   * };\n   *\n   * const injector = Injector.resolveAndCreate([\n   *   EnLocale,\n   *   SkLocale\n   *   { provide: Locale, useExisting: EnLocale, multi: true },\n   *   { provide: Locale, useExisting: SkLocale, multi: true },\n   * ]);\n   *\n   * const locales: Locale[] = injector.get(Locale);\n   * const localeNames: string[] = locals.map((l) => l.name);\n   * expect(localeNames).toEqual(['en', 'sk']);\n   * ```\n   */\n  multi?: boolean;\n}\n\n/**\n * Configures the {@link Injector} to return a value by invoking a `useFactory` function.\n *\n * ### Example\n * ```javascript\n * const HASH = new OpaqueToken('hash');\n *\n * const injector = Injector.resolveAndCreate([\n *   {provide: Location, useValue: window.location},\n *   {provide: HASH, useFactory: (location: Location) => location.hash, deps: [Location]}\n * ]);\n *\n *\n * // Assume location is: http://angular.io/#someLocation\n * expect(injector.get(HASH)).toEqual('someLocation');\n * ``\n * @stable\n */\nexport interface FactoryProvider {\n  /**\n   * An injection token. (Typically an instance of `Type` or `OpaqueToken`, but can be `any`).\n   */\n  provide: any;\n\n  /**\n   * A function to invoke to create a value for this `token`. The function is invoked with\n   * resolved values of `token`s in the `deps` field.\n   */\n  useFactory: Function;\n\n  /**\n   * A list of `token`s which need to be resolved by the injector. The list of values is than\n   * used as arguments to the `useFactory` function.\n   */\n  deps?: any[];\n\n  /**\n   * If true, than injector returns an array of instances. This is useful to allow multiple\n   * providers spread across many files to provide configuration information to a common token.\n   *\n   * ### Example\n   * ```javascript\n   * class Locale {\n   *   constructor(public name: string) {}\n   * };\n   * const PRIMARY = new OpequeToken('primary');\n   * const SECONDARY = new OpequeToken('secondary');\n   *\n   * const injector = Injector.resolveAndCreate([\n   *   { provide: PRIMARY: useValue: 'en'},\n   *   { provide: SECONDARY: useValue: 'sk'},\n   *   { provide: Locale, useFactory: (n) => new Locale(n), deps: [PRIMARY], multi: true},\n   *   { provide: Locale, useFactory: (n) => new Locale(n), deps: [SECONDARY], multi: true},\n   * ]);\n   *\n   * const locales: Locale[] = injector.get(Locale);\n   * const localeNames: string[] = locals.map((l) => l.name);\n   * expect(localeNames).toEqual(['en', 'sk']);\n   * ```\n   */\n  multi?: boolean;\n}\n\n/**\n * Describes how the {@link Injector} should be configured.\n *\n * See {@link TypeProvider}, {@link ValueProvider}, {@link ClassProvider}, {@link ExistingProvider},\n * {@link FactoryProvider}.\n *\n * ```javascript\n * class Greeting {\n *   salutation = 'Hello';\n * }\n *\n * class FormalGreeting extends Greeting {\n *   salutation = 'Greetings';\n * }\n *\n * abstract class Operation {\n *   apply(a,b): any;\n * }\n *\n * class AddOperation extends Operation {\n *   apply(a,b) { return a+b; }\n * }\n *\n *\n * const injector = Injector.resolveAndCreate([\n *   FormalGreeting,\n *   {provide: String, useValue: 'Hello World!'},\n *   {provide: Greeting, useExisting: FormalGreeting},\n *   {provide: Operation, useClass: AddOperation},\n *   {provide: Number, useFactory: (op) =>op.apply(1,2), deps: [Operation] }\n * ]);\n *\n * expect(injector.get(FormalGreeting).name).toEqual('Greetings');\n * expect(injector.get(String).name).toEqual('Hello World!');\n * expect(injector.get(Greeting).name).toBe(injector.get(FormalGreeting));\n * expect(injector.get(Number).toEqual(3);\n * ```\n * @stable\n */\nexport type Provider =\n    TypeProvider | ValueProvider | ClassProvider | ExistingProvider | FactoryProvider | any[];\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}